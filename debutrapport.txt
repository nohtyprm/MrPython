Apres diverses atermoiements concernant le choix de l’implémentation,
Nous sommes d’abord passés par une map, intégrée au contexte, qui recenserait les autorisations sur les variables, càd si elles sont modifiables et / ou copiables. Il  avait donc différents degrés d’autorisation sur chaque variable, suivant son initialisation.

La solution présente intègre les flags aux types, solution qui présente l’avantage de ne devoir quasiment rien vérifier à l’appel de méthode, à part si le type de l’expression sur laquelle la méthode est appelée est flaguée ou non. De même, cela facilite grandement le stockage des flags, car il suffit de les stocker dans les classes des types mutables (ou dans le typeast pour faciliter l’implémentation), et l’accès au flag se fait immédiatement avec un getter, sans devoir passer par une map, et donc ajouter une structure de donnée au typer ou devoir changer la structure de l’environnement local, avec tout ce que cela implique comme modifications de code. Il n’y a également pas la problématique de devoir faire remonter l’information sur le flag au top level comme la solution avec les maps précédemment obtenue, comme à chaque type_infer on fait remonter une information de type, il suffit juste de stocker l’information de modificabilité dans le type.
Cela permet également d’avoir une approche plus fine, qui sera expliquée plus en détails sur les exemples mais grossièrement, on peut flaguer un sous-type en particulier ; si on a une liste à plusieurs niveaux, disons une list[list[int]] et qu’un des paramètres, une list[int] a été ajouté à cette liste lors de l’initialisation. Alors, on peut faire un ajout de list[int] sur la list[list[int]] sans avoir d’effet de bord, mais un ajout de int peut potentiellement modifier le paramètre. Il faut donc interdire cette deuxième situation, sans pour autant interdire la première (ce genre de cas ne se présentera sans doute pas du tout, mais autorisons-le quand même car on veut être le plus souple possible concernant les interdictions). Ce genre de problème n’aurait pas pu être traité par la première approche, ce qui nous a y fait renoncer.
L’information stockée dans le typeast tient en 2 attributs ; modifiable_flag et flag_lvl. La première variable nous indique simplement si le type considéré est modifiable ou non (i.e. si on peut faire appel ou non à une méthode ayant un effet de bord sur l’objet receveur). Le deuxième attribut, flag_lvl, nous indique le niveau auquel est situé la variable non modifiable (le getter renvoie infini si le type considéré n’est pas mutable, ou est mutable mais ne contient pas de références vers des paramètres). Ce deuxième attribut nous sert dans des exemples un peu plus complexes dans lesquelles avoir juste modifiable_flag ne suffirait pas. A DETAILLER.

